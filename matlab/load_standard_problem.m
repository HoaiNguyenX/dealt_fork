function load_standard_problem(C, problem, out_path, o, l, varargin)
% Evaluate the data generated by deal.t for a specific problem. The input
% arguments are as follows
%   C           -- A cell array containing strings. Each string relates to
%                  data to be evaluated. 
%   problem     -- The problem to be loaded specified as path
%   out_path    -- Save outputs to specified path
%   o           -- specify the degree of Tsplines used for the problem
%   l           -- specify a level of the mesh to be loaded
%   varargin    -- optional fig_no argument, if different figures are to be
%                  created
% 
% The options for C are as follows
%   sparsity_pattern    -- load the sparsity pattern of the system
%                          matrix at a given degree and level
%   control_grid        -- plot the control grid of the problem. This is 
%                          hard-coded for the problems considered in the
%                          deal.t examples.
%   solution            -- Plot and output the numerical_solution on the
%                          domain
%   physical_grid       -- Plot and output the physical grid for the given
%                          problem
%   real_solution       -- Plot the real solution of the considered problem
%
% Written by: Robin Hiniborch (hiniborch at ifam.uni-hannover.de)
%% Load parameters / Main function
% define path
path = [problem 'o' num2str(o) '/l' num2str(l)];

if isempty(varargin)
    fig_no = 1;
    dim = 1;
else 
    if length(varargin) == 1
        fig_no = varargin{1};
        dim = 1;
    elseif length(varargin) == 2
        fig_no = varargin{1};
        dim    = varargin{2};
    end
end

for i = 1:length(C)
    f = figure(fig_no); fig_no = fig_no + 1;
    % f.WindowStyle = 'docked';
    plot_data(C{i}, path, dim);
    if ~isempty(out_path)
        print_figure(f, out_path, C{i})
    else
        title(C{i})
        colorbar
    end
end


end % main

function plot_data(c, path, dim)
% Plot the data specified by c for the problem in path

% Load a proper colormap, since matlabs colors are trash
cmap = load('smooth-cool-warm.dat') / 255;

% Load LUH-colors for line-plots
luh_colors;
N1 = 100; N2 = 100;

% Define a linewidth
lw = 2;
switch c
    case 'sparsity_pattern'
        sp_f = [path '_sp.dat'];
        fid = fopen(sp_f);
        
        tline = fgetl(fid);
        
        non_sparse = [];
        while ischar(tline)
            % Remove brackets:
            tline(1) = []; tline(end) = [];
            
            % Split line at commas
            C = strsplit(tline, ',');
            a = zeros(length(C), 1);
            
            % Convert strings to numbers
            for k = 1:length(C)
                a(k) = str2double(C{k}) + 1;
            end
            
            % Get indices of non-zero entries
            non_sparse(end+1, a(2:end)) = 1;
            
            % Get next line
            tline = fgetl(fid);
        end
        sp = sparse(non_sparse);
        spy(sp);
        title(['DoFs: ' num2str(size(non_sparse, 1))])

        
        fclose(fid);
    case 'control_grid'
        % Plot the boundary outline
        if dim == 1
            [bdry_x, bdry_y]    = get_squished_rectangle_outline;
            P                   = get_squished_rectangle_controls;
            quads               = get_squished_rectangle_quads; 
            ticks               = get_squished_rectangle_ticks;
        else 
            [bdry_x, bdry_y]    = get_distorted_rectangle_outline;
            P                   = get_distorted_rectangle_controls;
            quads               = get_distorted_rectangle_quads; 
            ticks               = get_distorted_rectangle_ticks;
        end
        
        plot(bdry_x, bdry_y, 'LineWidth', lw, 'Color', 'black'); hold on;
        
        plot(P(:, 1), P(:, 2), ...
            'LineWidth', lw, ...
            'Color', LUH_red, ...
            'LineStyle', 'none', ...
            'Marker', 'x', ...
            'MarkerSize', 5 * lw ...
            )
        

        for i = 1:size(quads, 2)
            plot(P(quads(:, i), 1), P(quads(:, i), 2), ...
                'LineWidth', lw, ...
                'Color', LUH_red, ...
                'LineStyle', '--' ...
                )
        end
        xlim([min(P(:, 1)) max(P(:, 1))]);
        ylim([min(P(:, 2)) max(P(:, 2))]);
        
        set(gca, 'xtick', ticks{1}, ...
            'ytick', ticks{2}, ...
            'FontSize', 25, ...
            'XtickLabel', ticks{3}, ...
            'YtickLabel', ticks{4} ...
            );
        grid on;
        hold off;
    case 'solution'
        uh_f  = [path '_numerical_solution.dat'];
        uh = reshape(load(uh_f), N1, N2);
        
        if dim == 1
            [X, Y] = get_squisehd_rectangle_evals();
            uh_f  = [path '_numerical_solution.dat'];
            uh = reshape(load(uh_f), N1, N2);
        else 
            error(1);
        end
        contourf(X, Y, uh, 'EdgeColor', 'none'); hold on;
        colormap(cmap(:, 2:4));
        
        Grid = [path '_mesh.txt'];
        plot_from_mesh_file(Grid, 'Color', 'black', 'LineWidth', lw);
        hold off;
    case 'physical_grid'
        Grid = [path '_mesh.txt'];
        plot_from_mesh_file(Grid, 'Color', 'black', 'LineWidth', lw);
        hold off;
    case 'displacement'
        if dim ~= 2 
            error(1);
        end 
        
        [bdry_x, bdry_y] = get_distorted_rectangle_outline;
        ux = @(x, y) (x + 0.5) .* sin(pi * y)/pi^2;
        uy = @(x, y) 0;
        
        displacement_x = bdry_x + ux(bdry_x, bdry_y);
        displacement_y = bdry_y + uy(bdry_x, bdry_y);
        
        plot(bdry_x, bdry_y, 'LineWidth', lw, 'Color', 'black'); hold on;
        plot(displacement_x, displacement_y, 'LineWidth', lw, 'Color', LUH_red);
    case 'real_solution'
        
        if dim == 1
            [X, Y] = get_squisehd_rectangle_evals();
            Z = 1/(5 * pi * pi) * sin(2 * pi * X) .* cos(1 * pi * Y);
            contourf(X, Y, Z, 'EdgeColor', 'none'); hold on;
            colormap(cmap(:, 2:4)); colorbar('FontSize', 25);
            
            [bdry_x, bdry_y] = get_squished_rectangle_outline;
            plot(bdry_x, bdry_y, 'LineWidth', lw, 'Color', 'black');
        else 
            [X, Y] = get_distorted_rectangle_evals();
            Z1 = (X + 0.5) .* sin(pi * Y)./pi^2;
            Z2 = zeros(size(X));
            [bdry_x, bdry_y] = get_distorted_rectangle_outline;
            zmin = min(Z1(:));
            zmax = max(Z1(:));

            fig = gcf;
            sp = subplot(2, 1, 1, 'Parent', fig);
            contourf(sp, X, Y, Z1, 'EdgeColor', 'none'); hold on; 
            caxis(sp, [zmin, zmax]);
            colormap(cmap(:, 2:4)); 
            plot(bdry_x, bdry_y, 'LineWidth', lw, 'Color', 'black');     
            
            sp = subplot(2, 1, 2, 'Parent', fig);
            contourf(sp, X, Y, Z2, [0 0 1]); hold on; 
            caxis(sp, [zmin, zmax]);
            colormap(cmap(:, 2:4)); 
            plot(bdry_x, bdry_y, 'LineWidth', lw, 'Color', 'black');
            
            h = axes(fig, 'visible', 'off');
            cb = colorbar(h, ... 
                            'FontSize', 25, ...
                            'Location', 'south', ...
                            'AxisLocation', 'out', ...
                            'Position', [0.1439    0.05    0.7480    0.0184]);
            caxis(h, [zmin, zmax]);
        end
       
        
        hold off;
    otherwise
        error();
end % switch

end % initialize_plot

function plot_from_mesh_file(name, varargin)

error(nargchk(1,inf,nargin,'struct'));
if nargin == 1
    varargin = {'Color', 'black', 'LineWidth', 2.5};
end


fid = fopen(name);
GridData = textscan(fid, '%f %f %f %f %f' ,1 , 'delimiter', '\n', 'headerlines', 0);
n_vertices_per_cell     = GridData{1};
n_cells                 = GridData{2};
n_vertices_total        = GridData{3};
solution_dimension      = GridData{4};
physical_dimension      = GridData{5};


% Extract Cell data
C = zeros(n_cells, n_vertices_per_cell);
fseek(fid,0,'bof');
if n_vertices_per_cell == 4
    c = textscan(fid, '%f %f %f %f', n_cells, 'delimiter', ' ', 'headerlines', 1);
else
    c = textscan(fid, '%f %f %f %f %f %f %f %f', n_cells, 'delimiter', ' ', 'headerlines', 1);
end

for i = 1:n_vertices_per_cell
    C(:, i) = c{i};
end

% Extract Vertex Data
V = zeros(n_vertices_total, physical_dimension);
fseek(fid,0,'bof');
if physical_dimension == 2
    f = textscan(fid, '%f %f', n_vertices_total, 'delimiter', ' ', 'headerlines', 1 + n_cells);
else
    f = textscan(fid, '%f %f %f', n_vertices_total, 'delimiter', ' ', 'headerlines', 1 + n_cells);
end
for i = 1:physical_dimension
    V(:, i) = f{i};
end

if solution_dimension ~= 0
    CM = zeros(n_vertices_total, solution_dimension);
    fseek(fid, 0, 'bof');
    if physical_dimension == 1
        cm = textscan(fid, '%f', n_vertices_total, 'delimiter', ' ', 'headerlines', 1 + n_cells + n_vertices);
    elseif physical_dimension == 2
        cm = textscan(fid, '%f %f', n_vertices_total, 'delimiter', ' ', 'headerlines', 1 + n_cells + n_vertices);
    else
        cm = textscan(fid, '%f %f %f', n_vertices_total, 'delimiter', ' ', 'headerlines', 1 + n_cells + n_vertices);
    end
    for i = 1:solution_dimension
        CM(:, i) = cm{i};
    end
end

quadplot(C+1, V(:, 1), V(:, 2), varargin{1:end})

end % plot_from_mesh_file

function P = get_distorted_rectangle_controls()
P = [0.0 0.0; ...
    0.5 0.0; ...
    1.0 0.0; ...
    -0.5 0.5; ...
    0.0 0.5; ...
    0.5 0.5; ...
    0.0 1.0; ...
    0.5 1.0; ...
    1.0 1.0
    ];
end % get_distorted_rectangle_controls

function [bdry_x, bdry_y] = get_distorted_rectangle_outline()

x = linspace(0., 1.);
y = linspace(0., 1.);
Phi = @(x, y) [x - y + y^2; y];

[bdry_x, bdry_y] = get_outline( Phi, x, y );

end % get_distorted_rectangle_outline

function P = get_squished_rectangle_controls()
P = [0.0 0.0; ...
    0.2 0.5; ...
    1.0 0.0; ...
    0.0 0.5; ...
    0.2 0.5; ...
    1.0 0.5; ...
    0.0 1.0; ...
    0.2 0.5; ...
    1.0 1.0
    ];
end % get_squished_rectangle_controls

function [bdry_x, bdry_y] = get_squished_rectangle_outline()

x = linspace(0., 1.);
y = linspace(0., 1.);
Phi = @(x, y) [0.4 * x + 0.6 * x.^2; ...
                x .* ( 1 - x) .* (1 - 2 .* y)  + y];

[bdry_x, bdry_y] = get_outline( Phi, x, y );

end % get_squished_rectangle_outline

function [bdry_x, bdry_y] = get_outline( Phi, x, y )

Nx = length(x);
Ny = length(y);

% Plot the outline of the domain
bdry_x = zeros(2*Nx + 2*Ny, 1);
bdry_y = zeros(2*Nx + 2*Ny, 1);

index = 1;
% y = 0
for i = 1:Nx
    p = Phi(x(i), y(1));
    bdry_x(index) = p(1);
    bdry_y(index) = p(2);
    index = index + 1;
end

% x = 1
for j = 1:Ny
    p = Phi(x(end), y(j));
    bdry_x(index) = p(1);
    bdry_y(index) = p(2);
    index = index + 1;
end

% y = 1
for i = Nx:-1:1
    p = Phi(x(i), y(end));
    bdry_x(index) = p(1);
    bdry_y(index) = p(2);
    index = index + 1;
end

% x = 0
for j = Ny:-1:1
    p = Phi(x(1), y(j));
    bdry_x(index) = p(1);
    bdry_y(index) = p(2);
    index = index + 1;
end

end % get_outline

function [X, Y] = get_squisehd_rectangle_evals()

x = linspace(-0., 1.);
y = linspace(-0., 1.);

Phi = @(x, y) [0.4 * x + 0.6 * x.^2; ...
                x .* ( 1 - x) .* (1 - 2 .* y)  + y];

[X, Y] = get_evals(Phi, x, y);

end % get_squisehd_Rectangle_points

function [X, Y] = get_distorted_rectangle_evals()

x = linspace(-0., 1.);
y = linspace(-0., 1.);

Phi = @(x, y) [x - y + y^2; y];

[X, Y] = get_evals(Phi, x, y);


end % get_distorted_rectangle_evals

function [X, Y] = get_evals(Phi, x, y)
X = zeros(100, 100);
Y = zeros(100, 100);
for j = 1:100
    for i = 1:100
        p = Phi(x(i), y(j));
        X(i, j) = p(1);
        Y(i, j) = p(2);
    end
end
end

function quads = get_squished_rectangle_quads()
quads = [1 2 5 4 1; ...
         2 3 6 5 2; ...
         4 5 8 7 4; ...
         5 6 9 8 5]' ;
end % get_squished_rectangle_quads

function quads = get_distorted_rectangle_quads()
quads =  [1 2 5 4 1; ...
         2 3 6 5 2; ...
         4 5 8 7 4; ...
         5 6 9 8 5]'  ;
end % get_distorted_rectangle_quads

function ticks = get_squished_rectangle_ticks()
    ticks = cell(1, 4);
    ticks{1} = [0, 0.2, 1.0]; 
    ticks{2} = [0, 0.5, 1.0];
    ticks{3} = {'0', '0.2', '1'};
    ticks{4} = {'0', '0.5', '1'};
end % get_squished_rectangle_ticks

function ticks = get_distorted_rectangle_ticks()
    ticks = cell(1, 4);
    ticks{1} = [-0.50, -0.25, 0.00, 0.50, 1.00]; 
    ticks{2} = [0.00, 0.50, 1.00];
    ticks{3} = {'-0.5', '-0.25', '0', '0.5', '1'};
    ticks{4} = {'0', '0.5', '1'};
end % get_distorted_rectangle_ticks

function print_figure(fig, out_path, name)

% Open current figure
figure(fig); 

% Ensure Window is not docked
fig.WindowStyle = 'normal'; 

switch name
    case 'cell_error'
        xi = true;
    case 'grid'
        xi = true;
    case 'physical_grid'
        xi = false;
    case 'physical_bezier_grid'
        xi = false; 
    case 'solution' 
        xi = false;
    case 'spline'
        xi = true;
    case 'real_solution'
        xi = false;
    case 'control_grid'
        xi = false;
    otherwise
        xi = false;
end % switch

fs = 25; 
if ~strcmp(name, 'sparsity_pattern')
    if xi
        xlabel('$$\xi_x$$', ...
            'Fontsize', fs, ...
            'Interpreter', 'latex',...
            'Color', 'black')
        ylabel('$$\xi_y$$', ...
            'Fontsize', fs, ...
            'Interpreter', 'latex',...
            'Color', 'black')
    else 
        xlabel('$$x$$', ...
            'Fontsize', fs, ...
            'Interpreter', 'latex', ...
            'Color', 'black')
        ylabel('$$y$$', ...
            'Fontsize', fs, ...
            'Interpreter', 'latex',...
            'Color', 'black')
    end
else 
    set(gca, 'FontSize', fs/2);
end
% set(gca, 'XTickLabel', []);
% set(gca, 'YTickLabel', []);
% set(gca, 'xtick', []);
% set(gca, 'ytick', []);
        

% Set position of figure
if ~strcmp(name, 'sparsity_pattern')
	fig.Position = [1389 101 1172 1073];
else 
	fig.Position = [577 239 1064 864];
end

% Get figure as matrix
frame        = getframe(fig);
im           = frame2im(frame);

% Set background to match block background on poster
% background = 230;
background = 255;

% This line removes some line artefacts. You will know, when to use it :-)
% im(repmat(all(im == 38, 3), 1, 1, 3)) = background;

% This line removes the gray background created by imwrite. 
im(repmat(all(im == 240, 3), 1, 1, 3)) = background;

% Write the file to a .png
[imind, cm]  = rgb2ind(im, 256);
imwrite(imind, cm, [out_path name '.png'], 'png');

% Note, that this is not a proper png. I cannot get the background to be
% opaque. If you do know how to do so, please feel free to send me a note!

end % print_figure